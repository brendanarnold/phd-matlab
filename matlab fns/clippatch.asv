function [of,ov,ofcolor]=clippatch(f,v,ofcolor,bplane_normals,incl_point,clipintersectedfaces);
%function [of,ov,ofcolor]=clippatch(f,v,bplane_normals,incl_point,clipintersectedfaces);
%
%ofcolor is a color index (single value) for each vertex (not face)
%takes faces (f) and vertices (v) e.g. as generated by isosurface and
%outputs only those that are within volume bounded by planes bplane_normals
%if clipintersectedfaces is true, faces that intersect planes will be split
%to avoid ragged edges

if isempty(f)
    disp('No faces!');
    return;
end

of=f;
warning off MATLAB:divideByZero;
for plnum=1:size(bplane_normals,1)    
    %define matrix of intersections of lines from incl_point to vertices
    %with bounding planes
    IntMatrix{plnum}=((bplane_normals(plnum,1)-incl_point(1))*bplane_normals(plnum,1)+...
        (bplane_normals(plnum,2)-incl_point(2))*bplane_normals(plnum,2)+...
        (bplane_normals(plnum,3)-incl_point(3))*bplane_normals(plnum,3))./...
        ((v(:,1)-incl_point(1))*bplane_normals(plnum,1)+...
        (v(:,2)-incl_point(2))*bplane_normals(plnum,2)+...        
        (v(:,3)-incl_point(3))*bplane_normals(plnum,3));
        %only keep those faces with at least one vertex on correct side of plane
        retain=(any(IntMatrix{plnum}(of)<0 | IntMatrix{plnum}(of)>1,2));
        of=of(retain,:);        
        ofcolor=ofcolor(retain,:);
end
disp(['Removed faces entirely outside region: ' num2str(size(f,1)) '->' num2str(size(of,1)) ' faces']);

if clipintersectedfaces
%now split faces that are intersected by planes
for plnum=1:size(bplane_normals,1)
    nvs=[];
    ifns=find(any(IntMatrix{plnum}(of)>0 & IntMatrix{plnum}(of)<1,2));
    disp([num2str(length(ifns)) ' faces intersected by plane ' num2str(plnum)]);
    for ifn=length(ifns):-1:1
        %note by defn intersected face has >=1 vertex outside plane and >=1
        %inside plane and either zero or 1 vertices on plane        
        nv_out=find(any(IntMatrix{plnum}(of(ifns(ifn),:))>0 & IntMatrix{plnum}(of(ifns(ifn),:))<1,2));
        nv_in=find(any(IntMatrix{plnum}(of(ifns(ifn),:))<0 | IntMatrix{plnum}(of(ifns(ifn),:))>1,2));
        v_out=v(of(ifns(ifn),nv_out(1)),:);
        v_in=v(of(ifns(ifn),nv_in(1)),:);
        nv_3=setdiff([1 2 3],[nv_out(1) nv_in(1)]);
        v_3=v(of(ifns(ifn),nv_3),:);
        orig_face=of(ifns(ifn),:);
        %need to have sense (cw/acw) of face verts right for correct shading
        sense_out2in=((1+mod(nv_out(1)-1+1,3))==nv_in(1));
        
        denom=dot(v_out-v_in,bplane_normals(plnum,:));
        if denom~=0
            lamda=dot(bplane_normals(plnum,:)-v_in,bplane_normals(plnum,:))/denom;
        else
            lamda=Inf;
        end
        nv_new=size(v,1)+size(nvs,1)+1;
        nvs(1+end,:)=v_in+lamda*(v_out-v_in);
        ofcolor(1+end,:)=ofcolor(of(ifns(ifn),nv_in(1)),:);
        if length(nv_out)==1
            %i.e. if 3rd vertex is on correct side of plane or on plane
            of(ifns(ifn),:)=[orig_face(nv_in(1)) nv_new orig_face(nv_3)];
            if sense_out2in
                of(ifns(ifn),:)=flipdim(of(ifns(ifn),:),2);
            end
        end
        if length(nv_in)==2
            denom=dot(v_3-v_out,bplane_normals(plnum,:));
            if denom~=0
                lamda=dot(bplane_normals(plnum,:)-v_out,bplane_normals(plnum,:))/denom;
            else
                lamda=Inf;
            end
            nvs(1+end,:)=v_out+lamda*(v_3-v_out);            
            ofcolor(1+end,:)=ofcolor(of(ifns(ifn),nv_out(1)),:);
            of=[of(1:ifns(ifn),:); [nv_new nv_new+1 orig_face(nv_3)]; of(ifns(ifn)+1:end,:)];                    
            if sense_out2in
                of(1+ifns(ifn),:)=flipdim(of(1+ifns(ifn),:),2);
            end
        elseif length(nv_out)==2            
            denom=dot(v_in-v_3,bplane_normals(plnum,:));
            if denom~=0
                lamda=dot(bplane_normals(plnum,:)-v_3,bplane_normals(plnum,:))/denom;
            else
                lamda=Inf;
            end
            nvs(1+end,:)=v_3+lamda*(v_in-v_3);            
            ofcolor(1+end,:)=ofcolor(of(ifns(ifn),nv_3),:);
            of(ifns(ifn),:)=[orig_face(nv_in(1)) nv_new nv_new+1];
            if sense_out2in
                of(ifns(ifn),:)=flipdim(of(ifns(ifn),:),2);
            end
        end
    end
    %need to find IntMatrix values for new vertices wrt to other planes
    %other vertices can only be outside if original face was
    %intersected
    if length(ifns)>0
    for plnum2=plnum+1:size(bplane_normals,1)
        IntMatrix{plnum2}(size(v,1)+1:size(v,1)+size(nvs,1))=...
            ((bplane_normals(plnum2,1)-incl_point(1))*bplane_normals(plnum2,1)+...
            (bplane_normals(plnum2,2)-incl_point(2))*bplane_normals(plnum2,2)+...
            (bplane_normals(plnum2,3)-incl_point(3))*bplane_normals(plnum2,3))./...
            ((nvs(:,1)-incl_point(1))*bplane_normals(plnum2,1)+...
            (nvs(:,2)-incl_point(2))*bplane_normals(plnum2,2)+...        
            (nvs(:,3)-incl_point(3))*bplane_normals(plnum2,3));
        %split faces may be entirely outside region so filter these out
        retain=(any(IntMatrix{plnum2}(of)<0 | IntMatrix{plnum2}(of)>1,2));
        of=of(retain,:);        
        ofcolor=ofcolor(retain,:);
    end
    v=[v; nvs];
    end
end    
end    
    
warning on MATLAB:divideByZero;
%ofcolor=repmat([1 0 0],size(of,1),1);
ov=v;

